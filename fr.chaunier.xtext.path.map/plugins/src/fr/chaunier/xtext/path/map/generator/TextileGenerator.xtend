/*
 * generated by Xtext
 */
 
package fr.chaunier.xtext.path.map.generator

import fr.chaunier.xtext.path.map.utils.PathMappingBuilder
import fr.chaunier.xtext.path.map.utils.FunctionArgs
import fr.chaunier.xtext.path.map.utils.MapArgs
import fr.chaunier.xtext.path.map.utils.PathMapFeature
import fr.chaunier.xtext.path.map.utils.RuleArgs
import fr.chaunier.xtext.path.map.utils.SetArgs
import fr.chaunier.xtext.path.map.pathDsl.ModelMap
import fr.chaunier.xtext.path.map.pathDsl.FileSpecModel
import fr.chaunier.xtext.path.map.pathDsl.SpecInfo
import fr.chaunier.xtext.path.map.pathDsl.SpecVersion
import fr.chaunier.xtext.path.map.pathDsl.SpecLine
import fr.chaunier.xtext.omc.FeaturePathBuilder
import fr.chaunier.xtext.omc.Helpers
import fr.chaunier.xtext.omc.InstancePathManager
import fr.chaunier.xtext.omc.OmHelper
import fr.chaunier.xtext.omc.generator.msg.MessageFactory
import fr.chaunier.xtext.omc.omcDsl.Attribute
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.internal.xtend.util.Pair
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import fr.chaunier.xtext.path.map.DumpPathMapFeature

import static extension org.eclipse.xtext.xtend2.lib.ResourceExtensions.*
import fr.chaunier.xtext.omc.DumpInstancePath


class TextileGenerator implements IGenerator {

	override void doGenerate(Resource input, IFileSystemAccess fsa) {
		
		
		var generatorExtensions = new MapGeneratorExtensions()
	    for(modelMap : input.allContentsIterable.filter(typeof(ModelMap))) {
	    	if ( modelMap.spec != null && modelMap.spec.mapping != null )
		      	fsa.generateFile(generatorExtensions.fileName(modelMap), compileTxt(modelMap))
		}
	}

//    @Inject CompletePathMappingBuilder builder 
//    @Inject OmHelper omHelper 

//		// use the standard configuration
//		Xtend11_Modularization instance = Guice.createInjector().getInstance(Xtend11_Modularization.class);

//	«var dump = new DumpPathMapFeature()»
//	«var d = dump.dump(pairMap)»

	def compileTxt(ModelMap mdl) '''
	«IF mdl.spec.mapping == null» ""
	«ELSE»
	«var builder = new PathMappingBuilder()»
	«var pairMap = builder.map(mdl)»
	«val entityHelper = new OmHelper()»
	«val iconPath = '../' + Helpers::getRelativeRoot(entityHelper.QualifiedName(mdl.spec.mapping)) + 'icons/'»
	«dumpSpec(mdl)»
	«dumpMappingView(mdl,pairMap,iconPath)»
	«dumpFromView(mdl,pairMap)»
	«dumpToView(mdl,pairMap)»
	«ENDIF»
'''

	def dumpSpec(ModelMap mdl) '''
«var omHelper = new OmHelper()»
«val entitySrc = omHelper.QualifiedName(mdl.spec.mapping.entityFrom)»
«val entityTarget = omHelper.QualifiedName(mdl.spec.mapping.entityTo)»
|**Model**»|«mdl.spec.mapping.name»|
|**Source**|«entitySrc.toString»|
|**Target**|«entityTarget.toString»|
«dumpSpec(mdl.spec)»
'''
 
def dumpMappingView(ModelMap mdl,PathMapFeature pairMap,String iconPath) '''
«var omHelper = new OmHelper()»

h3. mapping

table{border:1px solid black}.
|_. **Source** |_. |_. Feature |_. [..] |_. Constraint |_. |_. **Target** |_. |_. Feature |_. [..] |_. Constraint  |_. Rule
		«FOR mapFromTo:pairMap.pathMaps»
	«var cf = pairMap.getFeatureFrom(mapFromTo.first) as Attribute»
	«var st = pairMap.getFeatureTo(mapFromTo.second)  as Attribute»
	«var msgRenderer = MessageFactory::messageInstance»
	«msgRenderer.setIconPath(iconPath)»
    «val iconCf=msgRenderer.elementType(cf)»
    «val iconSt=msgRenderer.elementType(st)»
    «val src= getPath(mdl.spec.sourcePath,mapFromTo.first)»
    «val target=getPath(mdl.spec.targetPath,mapFromTo.second)»
 |«src» | «msgRenderer.constraintType(cf)» | «getReference(cf)» | «msgRenderer.cardinality(cf)» | «msgRenderer.constraintInFeature(cf)»  | -> | «target»  | «msgRenderer.constraintType(st)» | «getReference(st)» | «msgRenderer.cardinality(st)» | «msgRenderer.constraintInFeature(st)» | «renderArgs(pairMap,mapFromTo)» 
	«ENDFOR»
'''

	
	def getReference(Attribute a) {
	var omHelper = new OmHelper()
	if ( a == null ) return ""
	if ( a.type == null || a.type.referenced == null ) return ""
	var qn = omHelper.QualifiedName(a.type.referenced)
	if ( qn != null )
		qn.toString
	else ""
	} 

	def dumpFromView(ModelMap mdl,PathMapFeature pairMap) '''
	
	h3. source oriented mapping view
	
	«var path = new FeaturePathBuilder()»
	«var instanceManager = new InstancePathManager(mdl.spec.mapping.entityFrom)»
	«path.compilePath(mdl.spec.mapping.entityFrom,instanceManager)»
	
	table{border:1px solid black}.
	| **source** |  | **destination** | 
	«FOR pFrom:instanceManager.paths»
	«val pTos = pairMap.getPathsFrom(pFrom)» 
    «val src= getPath(mdl.spec.sourcePath,pFrom)»
	«IF pTos.empty»
	| «src» |  -> |   |     
	«ELSE»
	«FOR pTo:pTos»
	«var args = pairMap.getMapArgs(pFrom,pTo)»
    «val target=getPath(mdl.spec.targetPath,pTo)»
	| «src» |  -> |  «target» | «renderArgs(args)»    
	«ENDFOR»
	«ENDIF»
	«ENDFOR»
	'''

/*	«var dump = new DumpInstancePath()»
	«var e = dump.dump(instanceManager)»
 */

	def dumpToView(ModelMap mdl,PathMapFeature pairMap) '''
		
	h3. taget oriented view mapping
	
	«var path = new FeaturePathBuilder()»
	«var instanceManager = new InstancePathManager(mdl.spec.mapping.entityTo)»
	«path.compilePath(mdl.spec.mapping.entityTo,instanceManager)»
	
	table{border:1px solid black}.
	| **source** |  | **destination** |  
	«FOR pTo:instanceManager.paths»
    «val target=getPath(mdl.spec.targetPath,pTo)»
	«val pFroms = pairMap.getPathsTo(pTo)»
	«IF pFroms.empty»
	|  |  -> |  «target».«pTo» | |
	«ELSE» 
	«FOR pFrom : pFroms» 
    «val src= getPath(mdl.spec.sourcePath,pFrom)»
	«var args = pairMap.getMapArgs(pFrom,pTo)»
	| «src» |  -> |  «target».«pTo» | «renderArgs(args)» 
	«ENDFOR»
	«ENDIF»
	«ENDFOR»
	'''


def renderArgs(PathMapFeature pathMap,Pair<String,String> mapFromTo) {
		val args = pathMap.getMapArgs(mapFromTo)
		if ( args != null ) renderArgs(args)
		else return ''	
	}

def dispatch renderArgs(MapArgs args) {
	if (args == null ) 
		return ""
	return args.name
}
	
def dispatch renderArgs(SetArgs args) {
	return args.name //+ ' ' + args.value
}

def dispatch renderArgs(RuleArgs args) {
	return args.name + ' ' + args.args 
}

def dispatch renderArgs(FunctionArgs args) {
	return args.name + ' ' + args.operation 
}

	def getPath(String prefix,String body) {
		if ( body == null )
			return ""
		if ( prefix != null){
			return prefix+'.'+body
		} else return body
	}


	def dumpSpec(FileSpecModel specs) {
		if ( specs != null )
		for ( sl : specs.specLines )
			 dumpSpec(sl)
	} 
	

	def dispatch dumpSpec(SpecLine psec) '''
	'''

	def dispatch dumpSpec(SpecInfo spec) '''
		**«spec.title»** | «spec.label»
	''' 

	def dispatch dumpSpec(SpecVersion spec) '''
		**version : «spec.version»** | «spec.comment»
	''' 
}



	
