/*
* generated by Xtext
*/

package fr.chaunier.xtext.archi.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class AdslDslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ArchiModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArchiModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsSystemParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		
		////import  "platform:/resource/fr.chaunier.xtext.constraint/src-gen/fr/chaunier/xtext/constraint/CstDsl.ecore" as cst 
		//ArchiModel:
		//	imports+=Import* elements+=System*;
		public ParserRule getRule() { return rule; }

		//imports+=Import* elements+=System*
		public Group getGroup() { return cGroup; }

		//imports+=Import*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }

		//Import
		public RuleCall getImportsImportParserRuleCall_0_0() { return cImportsImportParserRuleCall_0_0; }

		//elements+=System*
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }

		//System
		public RuleCall getElementsSystemParserRuleCall_1_0() { return cElementsSystemParserRuleCall_1_0; }
	}

	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportedNamespaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportedNamespaceQualifiedNameWithWildCardParserRuleCall_1_0 = (RuleCall)cImportedNamespaceAssignment_1.eContents().get(0);
		
		//Import:
		//	"import" importedNamespace=QualifiedNameWithWildCard;
		public ParserRule getRule() { return rule; }

		//"import" importedNamespace=QualifiedNameWithWildCard
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//importedNamespace=QualifiedNameWithWildCard
		public Assignment getImportedNamespaceAssignment_1() { return cImportedNamespaceAssignment_1; }

		//QualifiedNameWithWildCard
		public RuleCall getImportedNamespaceQualifiedNameWithWildCardParserRuleCall_1_0() { return cImportedNamespaceQualifiedNameWithWildCardParserRuleCall_1_0; }
	}

	public class QualifiedNameWithWildCardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedNameWithWildCard");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//QualifiedNameWithWildCard:
		//	QualifiedName ".*"?;
		public ParserRule getRule() { return rule; }

		//QualifiedName ".*"?
		public Group getGroup() { return cGroup; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_0() { return cQualifiedNameParserRuleCall_0; }

		//".*"?
		public Keyword getFullStopAsteriskKeyword_1() { return cFullStopAsteriskKeyword_1; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	ID ("." ID)*;
		public ParserRule getRule() { return rule; }

		//ID ("." ID)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("." ID)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}

	public class SystemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "System");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSystemKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cUsingsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cUsingsUsingParserRuleCall_3_0 = (RuleCall)cUsingsAssignment_3.eContents().get(0);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Assignment cSubSystemsAssignment_4_0 = (Assignment)cAlternatives_4.eContents().get(0);
		private final RuleCall cSubSystemsSystemParserRuleCall_4_0_0 = (RuleCall)cSubSystemsAssignment_4_0.eContents().get(0);
		private final Assignment cComponentsAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final RuleCall cComponentsComponentParserRuleCall_4_1_0 = (RuleCall)cComponentsAssignment_4_1.eContents().get(0);
		private final Assignment cInterfacesAssignment_4_2 = (Assignment)cAlternatives_4.eContents().get(2);
		private final RuleCall cInterfacesInterfaceParserRuleCall_4_2_0 = (RuleCall)cInterfacesAssignment_4_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//System:
		//	"system" name=ID "{" usings+=Using* (subSystems+=System //		  | datatypes+=[mm::Entity]
		//	| components+=Component | interfaces+=Interface)* "}";
		public ParserRule getRule() { return rule; }

		//"system" name=ID "{" usings+=Using* (subSystems+=System //		  | datatypes+=[mm::Entity]
		//| components+=Component | interfaces+=Interface)* "}"
		public Group getGroup() { return cGroup; }

		//"system"
		public Keyword getSystemKeyword_0() { return cSystemKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//usings+=Using*
		public Assignment getUsingsAssignment_3() { return cUsingsAssignment_3; }

		//Using
		public RuleCall getUsingsUsingParserRuleCall_3_0() { return cUsingsUsingParserRuleCall_3_0; }

		//(subSystems+=System //		  | datatypes+=[mm::Entity]
		//| components+=Component | interfaces+=Interface)*
		public Alternatives getAlternatives_4() { return cAlternatives_4; }

		//subSystems+=System
		public Assignment getSubSystemsAssignment_4_0() { return cSubSystemsAssignment_4_0; }

		//System
		public RuleCall getSubSystemsSystemParserRuleCall_4_0_0() { return cSubSystemsSystemParserRuleCall_4_0_0; }

		//components+=Component
		public Assignment getComponentsAssignment_4_1() { return cComponentsAssignment_4_1; }

		//Component
		public RuleCall getComponentsComponentParserRuleCall_4_1_0() { return cComponentsComponentParserRuleCall_4_1_0; }

		//interfaces+=Interface
		public Assignment getInterfacesAssignment_4_2() { return cInterfacesAssignment_4_2; }

		//Interface
		public RuleCall getInterfacesInterfaceParserRuleCall_4_2_0() { return cInterfacesInterfaceParserRuleCall_4_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class UsingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Using");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUsingKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSystemAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cSystemSystemCrossReference_1_0 = (CrossReference)cSystemAssignment_1.eContents().get(0);
		private final RuleCall cSystemSystemIDTerminalRuleCall_1_0_1 = (RuleCall)cSystemSystemCrossReference_1_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Using:
		//	"using" system=[System] ";";
		public ParserRule getRule() { return rule; }

		//"using" system=[System] ";"
		public Group getGroup() { return cGroup; }

		//"using"
		public Keyword getUsingKeyword_0() { return cUsingKeyword_0; }

		//system=[System]
		public Assignment getSystemAssignment_1() { return cSystemAssignment_1; }

		//[System]
		public CrossReference getSystemSystemCrossReference_1_0() { return cSystemSystemCrossReference_1_0; }

		//ID
		public RuleCall getSystemSystemIDTerminalRuleCall_1_0_1() { return cSystemSystemIDTerminalRuleCall_1_0_1; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class ComponentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Component");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cComponentKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPortsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPortsPortParserRuleCall_3_0 = (RuleCall)cPortsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// components have names and ports
		////Component:
		////	 BlComponent | DBComponent;
		//Component:
		//	"component" name=ID "{" ports+=Port* //		(configuration=ComponentConfiguration)?		
		//	"}";
		public ParserRule getRule() { return rule; }

		//"component" name=ID "{" ports+=Port* //		(configuration=ComponentConfiguration)?		
		//"}"
		public Group getGroup() { return cGroup; }

		//"component"
		public Keyword getComponentKeyword_0() { return cComponentKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//ports+=Port*
		public Assignment getPortsAssignment_3() { return cPortsAssignment_3; }

		//Port
		public RuleCall getPortsPortParserRuleCall_3_0() { return cPortsPortParserRuleCall_3_0; }

		////		(configuration=ComponentConfiguration)?		
		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class PortElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Port");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cProvidedPortParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRequiredPortParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// a port is either a provided port or a required port
		//Port:
		//	ProvidedPort | RequiredPort;
		public ParserRule getRule() { return rule; }

		//ProvidedPort | RequiredPort
		public Alternatives getAlternatives() { return cAlternatives; }

		//ProvidedPort
		public RuleCall getProvidedPortParserRuleCall_0() { return cProvidedPortParserRuleCall_0; }

		//RequiredPort
		public RuleCall getRequiredPortParserRuleCall_1() { return cRequiredPortParserRuleCall_1; }
	}

	public class ProvidedPortElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProvidedPort");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProvidesKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIsMandatoryAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cIsMandatoryMandatoryKeyword_1_0 = (Keyword)cIsMandatoryAssignment_1.eContents().get(0);
		private final Assignment cIsToManyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cIsToManyToManyKeyword_2_0 = (Keyword)cIsToManyAssignment_2.eContents().get(0);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cInterfaceAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cInterfaceInterfaceCrossReference_5_0 = (CrossReference)cInterfaceAssignment_5.eContents().get(0);
		private final RuleCall cInterfaceInterfaceIDTerminalRuleCall_5_0_1 = (RuleCall)cInterfaceInterfaceCrossReference_5_0.eContents().get(1);
		
		//// provided ports offer interfaces for use by other
		//// components. Ports can be mandatory and/or expect 
		//// a collection of clients. Ports also have a name.
		//ProvidedPort:
		//	"provides" isMandatory?="mandatory"? isToMany?="toMany"? name=ID ":" interface=[Interface];
		public ParserRule getRule() { return rule; }

		//"provides" isMandatory?="mandatory"? isToMany?="toMany"? name=ID ":" interface=[Interface]
		public Group getGroup() { return cGroup; }

		//"provides"
		public Keyword getProvidesKeyword_0() { return cProvidesKeyword_0; }

		//isMandatory?="mandatory"?
		public Assignment getIsMandatoryAssignment_1() { return cIsMandatoryAssignment_1; }

		//"mandatory"
		public Keyword getIsMandatoryMandatoryKeyword_1_0() { return cIsMandatoryMandatoryKeyword_1_0; }

		//isToMany?="toMany"?
		public Assignment getIsToManyAssignment_2() { return cIsToManyAssignment_2; }

		//"toMany"
		public Keyword getIsToManyToManyKeyword_2_0() { return cIsToManyToManyKeyword_2_0; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//interface=[Interface]
		public Assignment getInterfaceAssignment_5() { return cInterfaceAssignment_5; }

		//[Interface]
		public CrossReference getInterfaceInterfaceCrossReference_5_0() { return cInterfaceInterfaceCrossReference_5_0; }

		//ID
		public RuleCall getInterfaceInterfaceIDTerminalRuleCall_5_0_1() { return cInterfaceInterfaceIDTerminalRuleCall_5_0_1; }
	}

	public class RequiredPortElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RequiredPort");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRequiresKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIsMandatoryAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cIsMandatoryMandatoryKeyword_1_0 = (Keyword)cIsMandatoryAssignment_1.eContents().get(0);
		private final Assignment cIsToManyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cIsToManyToManyKeyword_2_0 = (Keyword)cIsToManyAssignment_2.eContents().get(0);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cInterfaceAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cInterfaceInterfaceCrossReference_5_0 = (CrossReference)cInterfaceAssignment_5.eContents().get(0);
		private final RuleCall cInterfaceInterfaceIDTerminalRuleCall_5_0_1 = (RuleCall)cInterfaceInterfaceCrossReference_5_0.eContents().get(1);
		
		//// required ports access interfaces provided by other
		//// components. Ports can be mandatory and/or connect to
		//// a collection of providers. Ports also have a name.
		//RequiredPort:
		//	"requires" isMandatory?="mandatory"? isToMany?="toMany"? name=ID ":" interface=[Interface];
		public ParserRule getRule() { return rule; }

		//"requires" isMandatory?="mandatory"? isToMany?="toMany"? name=ID ":" interface=[Interface]
		public Group getGroup() { return cGroup; }

		//"requires"
		public Keyword getRequiresKeyword_0() { return cRequiresKeyword_0; }

		//isMandatory?="mandatory"?
		public Assignment getIsMandatoryAssignment_1() { return cIsMandatoryAssignment_1; }

		//"mandatory"
		public Keyword getIsMandatoryMandatoryKeyword_1_0() { return cIsMandatoryMandatoryKeyword_1_0; }

		//isToMany?="toMany"?
		public Assignment getIsToManyAssignment_2() { return cIsToManyAssignment_2; }

		//"toMany"
		public Keyword getIsToManyToManyKeyword_2_0() { return cIsToManyToManyKeyword_2_0; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//interface=[Interface]
		public Assignment getInterfaceAssignment_5() { return cInterfaceAssignment_5; }

		//[Interface]
		public CrossReference getInterfaceInterfaceCrossReference_5_0() { return cInterfaceInterfaceCrossReference_5_0; }

		//ID
		public RuleCall getInterfaceInterfaceIDTerminalRuleCall_5_0_1() { return cInterfaceInterfaceIDTerminalRuleCall_5_0_1; }
	}

	public class InterfaceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Interface");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInterfaceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInteractionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInteractionsMessageInteractionParserRuleCall_3_0 = (RuleCall)cInteractionsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// an interface has a name, and contains a number
		//// of message interactions (i.e. messages of different 
		//// kinds)
		//Interface:
		//	"interface" name=ID "{" interactions+=MessageInteraction* "}";
		public ParserRule getRule() { return rule; }

		//"interface" name=ID "{" interactions+=MessageInteraction* "}"
		public Group getGroup() { return cGroup; }

		//"interface"
		public Keyword getInterfaceKeyword_0() { return cInterfaceKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//interactions+=MessageInteraction*
		public Assignment getInteractionsAssignment_3() { return cInteractionsAssignment_3; }

		//MessageInteraction
		public RuleCall getInteractionsMessageInteractionParserRuleCall_3_0() { return cInteractionsMessageInteractionParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class MessageInteractionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MessageInteraction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cOnewayInteractionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRequestReplyInteractionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// message interactions are either oneways
		//// or request/replies
		//MessageInteraction:
		//	OnewayInteraction | RequestReplyInteraction;
		public ParserRule getRule() { return rule; }

		//OnewayInteraction | RequestReplyInteraction
		public Alternatives getAlternatives() { return cAlternatives; }

		//OnewayInteraction
		public RuleCall getOnewayInteractionParserRuleCall_0() { return cOnewayInteractionParserRuleCall_0; }

		//RequestReplyInteraction
		public RuleCall getRequestReplyInteractionParserRuleCall_1() { return cRequestReplyInteractionParserRuleCall_1; }
	}

	public class OnewayInteractionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OnewayInteraction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cOnewayKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMessageAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMessageMessageParserRuleCall_3_0 = (RuleCall)cMessageAssignment_3.eContents().get(0);
		
		//// oneway interactions have a name and a message
		//OnewayInteraction:
		//	"oneway" name=ID ":" message=Message;
		public ParserRule getRule() { return rule; }

		//"oneway" name=ID ":" message=Message
		public Group getGroup() { return cGroup; }

		//"oneway"
		public Keyword getOnewayKeyword_0() { return cOnewayKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//message=Message
		public Assignment getMessageAssignment_3() { return cMessageAssignment_3; }

		//Message
		public RuleCall getMessageMessageParserRuleCall_3_0() { return cMessageMessageParserRuleCall_3_0; }
	}

	public class RequestReplyInteractionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RequestReplyInteraction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRrKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRequestKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cRequestAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cRequestMessageParserRuleCall_5_0 = (RuleCall)cRequestAssignment_5.eContents().get(0);
		private final Keyword cReplyKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cEqualsSignKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cReplyAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cReplyMessageParserRuleCall_8_0 = (RuleCall)cReplyAssignment_8.eContents().get(0);
		
		//// request/reply has a name and two messages
		//RequestReplyInteraction:
		//	"rr" name=ID ":" "request" "=" request=Message "reply" "=" reply=Message;
		public ParserRule getRule() { return rule; }

		//"rr" name=ID ":" "request" "=" request=Message "reply" "=" reply=Message
		public Group getGroup() { return cGroup; }

		//"rr"
		public Keyword getRrKeyword_0() { return cRrKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//"request"
		public Keyword getRequestKeyword_3() { return cRequestKeyword_3; }

		//"="
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }

		//request=Message
		public Assignment getRequestAssignment_5() { return cRequestAssignment_5; }

		//Message
		public RuleCall getRequestMessageParserRuleCall_5_0() { return cRequestMessageParserRuleCall_5_0; }

		//"reply"
		public Keyword getReplyKeyword_6() { return cReplyKeyword_6; }

		//"="
		public Keyword getEqualsSignKeyword_7() { return cEqualsSignKeyword_7; }

		//reply=Message
		public Assignment getReplyAssignment_8() { return cReplyAssignment_8; }

		//Message
		public RuleCall getReplyMessageParserRuleCall_8_0() { return cReplyMessageParserRuleCall_8_0; }
	}

	public class MessageElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Message");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cParametersAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cParametersMessageParameterParserRuleCall_1_0_0 = (RuleCall)cParametersAssignment_1_0.eContents().get(0);
		private final Keyword cCommaKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// a message is a list of message parameters
		//Message:
		//	"(" (parameters+=MessageParameter ","?)* ")";
		public ParserRule getRule() { return rule; }

		//"(" (parameters+=MessageParameter ","?)* ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//(parameters+=MessageParameter ","?)*
		public Group getGroup_1() { return cGroup_1; }

		//parameters+=MessageParameter
		public Assignment getParametersAssignment_1_0() { return cParametersAssignment_1_0; }

		//MessageParameter
		public RuleCall getParametersMessageParameterParserRuleCall_1_0_0() { return cParametersMessageParameterParserRuleCall_1_0_0; }

		//","?
		public Keyword getCommaKeyword_1_1() { return cCommaKeyword_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class MessageParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MessageParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTyperefAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTyperefEntityCrossReference_2_0 = (CrossReference)cTyperefAssignment_2.eContents().get(0);
		private final RuleCall cTyperefEntityQualifiedNameParserRuleCall_2_0_1 = (RuleCall)cTyperefEntityCrossReference_2_0.eContents().get(1);
		
		//// and a message parameter has an ID and a type
		//// top level element is the file which
		//// can import other files and contains 
		//// a top level, root namespace
		/// *
		//File: 
		//	(featureModel=FeatureModelImport)?
		//	(imports+=Import)*
		//	(systems+=System |
		//	 compositions+=Composition |
		//	 topology+=Topology |
		//	 deployments+=Deployment |
		//	 makeFiles+=MakeFile)*;
		//
		//MakeFile:
		//	"make" name=ID "deployment" deployment=[Deployment] "{"
		//		(generatedComponnetAPIs+=ComponentAPIGenerationSpec)*
		//	"}";
		//
		//ComponentAPIGenerationSpec:
		//	"component" component=[Component];
		//
		//Topology:
		//	"topology" name=ID "{"
		//		(node+=Node)*
		//	"}";
		//
		//Node:
		//	AppServerNode | DbServerNode;
		//	
		//AppServerNode:
		//	"appserver" name=ID (clustered?="clustered")?;
		//
		//DbServerNode:
		//	"dbserver" name=ID (clustered?="clustered")?;
		//	
		//
		//Deployment:
		//	"deployment" name=ID 
		//		"deliverablesystem" deliverableSystem=[Composition]
		//		"topology" topology=[Topology] "{"
		//		(mappings+=InstanceNodeMapping)*
		//	"}";
		//	
		//InstanceNodeMapping:
		//	"map" nodeRef=[Node] "{"
		//		(instances+=InstanceRef)*
		//	"}";
		//		
		//InstanceRef:
		//	"instance" instance=[Instance];
		//	
		//
		//// an import makes another file accessible
		//// the current one          
		//Import:
		//	"import" importURI=STRING;
		//         
		//// namespaces are tne primary container of stuff,
		//// they can use other namespaces and can be nested 
		//System:
		//	(pointcut=Pointcut)?
		//	"system" name=ID 
		//	(tags=TagsClause)?
		//	(featureClause=FeatureClause)? 
		//	  "{"
		//		(usings+=Using)*	
		//		( subSystems+=System 
		//		  | components+=Component 
		//		  | datatypes+=DataType
		//		  | interfaces+=Interface
		//		 )* 
		//	"}"; 
		//
		//// using makes the contents of another system
		//// visible in the containing namespace. 
		//// note that the Using construct does not directly use a "reference to namespace"
		//// as the type of it's namespace property, because it is possible to have several
		//// namespace objects with the same (qualified) name! 
		//Using:
		//	"using" system=QualID ";";	
		//	
		//// components have names and ports
		//Component:
		//	UiComponent | BlComponent | PersComponent;
		//	
		//UiComponent:
		//	(pointcut=Pointcut)?
		//	"uicomponent" name=ID
		//	(tags=TagsClause)? 
		//	(featureClause=FeatureClause)?
		//	"{" 
		//		(ports+=Port)*
		//		(configuration=ComponentConfiguration)?		
		//	"}";
		//	
		//BlComponent:
		//	(pointcut=Pointcut)?
		//	"blcomponent" name=ID
		//	(tags=TagsClause)?
		//	(featureClause=FeatureClause)?
		//	"{" 
		//		(ports+=Port)*
		//		(configuration=ComponentConfiguration)?		
		//	"}";
		//	
		//PersComponent:
		//	(pointcut=Pointcut)?
		//	"persistencecomponent" name=ID 
		//	(tags=TagsClause)?
		//	(featureClause=FeatureClause)?
		//	"{" 
		//		(ports+=Port)*
		//		(configuration=ComponentConfiguration)?		
		//	"}";
		//	
		//// a port is either a provided port or a required port
		//Port:
		//	ProvidedPort | RequiredPort;
		//
		//// provided ports offer interfaces for use by other
		//// components. Ports can be mandatory and/or expect 
		//// a collection of clients. Ports also have a name.
		//ProvidedPort:
		//	"provides"
		//	(isMandatory?="mandatory")? 
		//	(isToMany?="toMany")? 
		//	name=ID ":" interface=[Interface|ID] 
		//    (featureClause=FeatureClause)? ";";
		//		
		//// required ports access interfaces provided by other
		//// components. Ports can be mandatory and/or connect to
		//// a collection of providers. Ports also have a name.
		//RequiredPort:
		//	"requires" 
		//	(isMandatory?="mandatory")? 
		//	(isToMany?="toMany")? 
		//	name=ID ":" interface=[Interface|ID] 
		//	(featureClause=FeatureClause)? ";";
		//
		//// an interface has a name, and contains a number
		//// of message interactions (i.e. messages of different 
		//// kinds)
		//Interface:
		//	"interface" name=ID (featureClause=FeatureClause)? 
		//	"{"
		//		(interactions+=MessageInteraction)*
		//	"}"; 
		//	
		//// message interactions are either oneways
		//// or request/replies
		//MessageInteraction:
		//	OnewayInteraction | RequestReplyInteraction;
		//	
		//// oneway interactions have a name and a message
		//OnewayInteraction:
		//	"oneway" name=ID ":" message=Message 
		//	(featureClause=FeatureClause)? ";";
		//
		//// request/reply has a name and two messages
		//RequestReplyInteraction:
		//	"rr" name=ID ":" "request" "=" request=Message "reply" "=" reply=Message 
		//	(featureClause=FeatureClause)? ";";
		// 	
		//// a message is a list of message parameters
		//Message:
		//	"(" (parameters+=MessageParameter (",")?)* ")";
		//	
		//// and a message parameter has an ID and a type
		//MessageParameter:
		//	name=ID ":" typeref=AnyTypeRef (featureClause=FeatureClause)?;	
		//
		//// data types are either primitive or complex	
		//DataType:
		//	PrimitiveType | ComplexType;
		//
		//// primitive types just have a name
		//PrimitiveType: 
		//	"primitive" name=ID 
		//	(featureClause=FeatureClause)? ";";	
		//
		//// complex types have a name and attributes
		//ComplexType: 
		//	"struct" name=ID 
		//	"{"
		//		(attributes+=Attribute)*
		//	"}";	
		//	 
		//// and attribute has a name and a type ref
		//Attribute:
		//	name=ID ":" typeref=AnyTypeRef 
		//	(featureClause=FeatureClause)? ";";	
		//	
		//// we use the typeref construct as the way to
		//// capture type modifers such as collections
		//// there are primitive type refs and any type refs	
		//DataTypeRef:
		//	PrimitiveTypeRef | AnyTypeRef;
		//	
		//// simple type refs are those without collections...	
		//AnyTypeRef:
		//	SimpleTypeRef | CollectionTypeRef;
		//
		//// for reasons of polymorphism, we type the type attribute
		//// to DataType, and not primitive type. Compensated via 
		//// Constraints and CC
		//PrimitiveTypeRef:
		//	type=[DataType|ID];  
		//	
		//// a refernece to a simple type
		//SimpleTypeRef:
		//	type=[DataType|ID];
		//	
		//// a collection of any type
		//CollectionTypeRef:
		//	"collection" type=[DataType|ID] ";";
		//	
		//	
		//
		//// a composition is a names collection of 
		//// instances and connectors
		//Composition:
		//	"deliverablesystem" name=ID (featureClause=FeatureClause)? "{"
		//		(instances+=Instance |
		//		 connectors+=Connector)*
		//	"}";
		//
		//// an instance is an inszance of a component	
		//Instance:
		//	"instance" name=ID ":" type=[Component]
		//		(configuration=InstanceConfiguration)?	
		//	 (featureClause=FeatureClause)? ";";	
		//
		//// a connector connects source ports with target ports
		//Connector:
		//	"connect" source=InstancePortPair "to" target=InstancePortPair ";";
		//
		//// references an instance/port tuple
		//InstancePortPair:
		//	instance=[Instance] "." port=[Port];	
		//
		//
		//ComponentConfiguration:
		//	"config" "{" 
		//		(params+=ConfigurationParameter)*
		//	"}";
		//
		//
		//ConfigurationParameter:
		//	valueTime=ValueTimeEnum name=ID ":" type=ConfigParamTypeEnum;
		//	 
		//InstanceConfiguration:
		//	"config" "{" 
		//		(settings+=ConfigurationParameterSetting)* 
		//	"}";	
		//	
		//enum ConfigParamTypeEnum:
		//	NUMBER = "numeric" | 
		//	TEXT = "text" | 
		//	BOOL = "boolean"; 	
		//	
		//ConfigurationParameterSetting:
		//	param=[ConfigurationParameter|ID] "=" value=ConfigurationParameterValue;
		//	
		//ConfigurationParameterValue:	
		//	NumericConfigurationParameterValue | 
		//	TextConfigurationParameterValue | 
		//	BooleanConfigurationParameterValue;
		//	
		//NumericConfigurationParameterValue:
		//	value=INT;
		// 
		//TextConfigurationParameterValue:
		//	value=STRING;
		// 
		//BooleanConfigurationParameterValue:
		//	value=BooleanLiteral;
		//	
		//BooleanLiteral:
		//	TrueLiteral | FalseLiteral;
		//		
		//TrueLiteral: "true";
		//
		//FalseLiteral: "false";		
		//	
		//enum ValueTimeEnum:
		//    NEVER="never (dummy)"  
		//	| INSTANCEDEFINITION="instancedef"
		//	| DEPLOYMENT="deployment"
		//	| STARTUP="startup"
		//	;
		//
		//	
		//// a tokenizer pattern for dot-separated names
		//QualID: ID ("." ID)*;
		//
		//
		////{ Feature Stuff 
		//// ******************
		//
		//FeatureClause:
		//	FeatureAndList | FeatureOrList | FeatureExpression | Feature ;
		//
		//FeatureAndList:
		//	"featureAndList" (retained?="retain")? "(" featureList+=ID ("," featureList+=ID)* ")";
		//  
		//FeatureOrList:  
		//	"featureOrList" (retained?="retain")? "(" featureList+=ID ("," featureList+=ID)* ")";
		//    
		//FeatureExpression:
		//	"featureExp" (retained?="retain")? "(" expression=OrExpression ")";     
		//    
		//Feature:
		//	"feature" (retained?="retain")? feature=ID;
		//	
		//OrExpression:
		//	operands+=AndExpression ("or" operands+=AndExpression)*;
		//
		//AndExpression:
		//	operands+=Operand ("and" operands+=Operand)*;
		//
		//Operand:
		//	(isNot?="not")? expression=Atom;
		//
		//Atom:
		//	feature=ID | "(" expression=OrExpression ")";	
		//	
		//FeatureModelImport:
		//	"featuremodel" uri=STRING ";";
		////}	
		//
		////{ Aspect Stuff
		//// *****************
		//TagsClause: 
		//	{TagsClause}
		//	"tags" "(" (tags+=Tag)* ")"; 
		//  
		//Tag: 
		//	name=ID;   
		//  
		// 
		//Pointcut:
		//	{Pointcut} 
		//	"aspect" "{" (matches+=Match)* "}"; 
		//  
		//Match: 
		//	AllMatch | ExactNameMatch | StartsWithNameMatch | EndsWithNameMatch | TagMatch ;
		//  
		//  
		//AllMatch: 
		//	"*"; 
		//  
		//ExactNameMatch: 
		//	"name" "=" name=ID; 
		//  
		//StartsWithNameMatch: 
		//	"name" "=" name=ID "*"; 
		//  
		//EndsWithNameMatch: 
		//	"name" "="  "*" name=ID; 
		//  
		//TagMatch: 
		//	"tag" "=" name=ID; 
		// * / MessageParameter:
		//	name=ID ":" typeref=[mm::Entity|QualifiedName];
		public ParserRule getRule() { return rule; }

		//name=ID ":" typeref=[mm::Entity|QualifiedName]
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//typeref=[mm::Entity|QualifiedName]
		public Assignment getTyperefAssignment_2() { return cTyperefAssignment_2; }

		//[mm::Entity|QualifiedName]
		public CrossReference getTyperefEntityCrossReference_2_0() { return cTyperefEntityCrossReference_2_0; }

		//QualifiedName
		public RuleCall getTyperefEntityQualifiedNameParserRuleCall_2_0_1() { return cTyperefEntityQualifiedNameParserRuleCall_2_0_1; }
	}
	
	
	private ArchiModelElements pArchiModel;
	private ImportElements pImport;
	private QualifiedNameWithWildCardElements pQualifiedNameWithWildCard;
	private QualifiedNameElements pQualifiedName;
	private SystemElements pSystem;
	private UsingElements pUsing;
	private ComponentElements pComponent;
	private PortElements pPort;
	private ProvidedPortElements pProvidedPort;
	private RequiredPortElements pRequiredPort;
	private InterfaceElements pInterface;
	private MessageInteractionElements pMessageInteraction;
	private OnewayInteractionElements pOnewayInteraction;
	private RequestReplyInteractionElements pRequestReplyInteraction;
	private MessageElements pMessage;
	private MessageParameterElements pMessageParameter;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public AdslDslGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////import  "platform:/resource/fr.chaunier.xtext.constraint/src-gen/fr/chaunier/xtext/constraint/CstDsl.ecore" as cst 
	//ArchiModel:
	//	imports+=Import* elements+=System*;
	public ArchiModelElements getArchiModelAccess() {
		return (pArchiModel != null) ? pArchiModel : (pArchiModel = new ArchiModelElements());
	}
	
	public ParserRule getArchiModelRule() {
		return getArchiModelAccess().getRule();
	}

	//Import:
	//	"import" importedNamespace=QualifiedNameWithWildCard;
	public ImportElements getImportAccess() {
		return (pImport != null) ? pImport : (pImport = new ImportElements());
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	//QualifiedNameWithWildCard:
	//	QualifiedName ".*"?;
	public QualifiedNameWithWildCardElements getQualifiedNameWithWildCardAccess() {
		return (pQualifiedNameWithWildCard != null) ? pQualifiedNameWithWildCard : (pQualifiedNameWithWildCard = new QualifiedNameWithWildCardElements());
	}
	
	public ParserRule getQualifiedNameWithWildCardRule() {
		return getQualifiedNameWithWildCardAccess().getRule();
	}

	//QualifiedName:
	//	ID ("." ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return (pQualifiedName != null) ? pQualifiedName : (pQualifiedName = new QualifiedNameElements());
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//System:
	//	"system" name=ID "{" usings+=Using* (subSystems+=System //		  | datatypes+=[mm::Entity]
	//	| components+=Component | interfaces+=Interface)* "}";
	public SystemElements getSystemAccess() {
		return (pSystem != null) ? pSystem : (pSystem = new SystemElements());
	}
	
	public ParserRule getSystemRule() {
		return getSystemAccess().getRule();
	}

	//Using:
	//	"using" system=[System] ";";
	public UsingElements getUsingAccess() {
		return (pUsing != null) ? pUsing : (pUsing = new UsingElements());
	}
	
	public ParserRule getUsingRule() {
		return getUsingAccess().getRule();
	}

	//// components have names and ports
	////Component:
	////	 BlComponent | DBComponent;
	//Component:
	//	"component" name=ID "{" ports+=Port* //		(configuration=ComponentConfiguration)?		
	//	"}";
	public ComponentElements getComponentAccess() {
		return (pComponent != null) ? pComponent : (pComponent = new ComponentElements());
	}
	
	public ParserRule getComponentRule() {
		return getComponentAccess().getRule();
	}

	//// a port is either a provided port or a required port
	//Port:
	//	ProvidedPort | RequiredPort;
	public PortElements getPortAccess() {
		return (pPort != null) ? pPort : (pPort = new PortElements());
	}
	
	public ParserRule getPortRule() {
		return getPortAccess().getRule();
	}

	//// provided ports offer interfaces for use by other
	//// components. Ports can be mandatory and/or expect 
	//// a collection of clients. Ports also have a name.
	//ProvidedPort:
	//	"provides" isMandatory?="mandatory"? isToMany?="toMany"? name=ID ":" interface=[Interface];
	public ProvidedPortElements getProvidedPortAccess() {
		return (pProvidedPort != null) ? pProvidedPort : (pProvidedPort = new ProvidedPortElements());
	}
	
	public ParserRule getProvidedPortRule() {
		return getProvidedPortAccess().getRule();
	}

	//// required ports access interfaces provided by other
	//// components. Ports can be mandatory and/or connect to
	//// a collection of providers. Ports also have a name.
	//RequiredPort:
	//	"requires" isMandatory?="mandatory"? isToMany?="toMany"? name=ID ":" interface=[Interface];
	public RequiredPortElements getRequiredPortAccess() {
		return (pRequiredPort != null) ? pRequiredPort : (pRequiredPort = new RequiredPortElements());
	}
	
	public ParserRule getRequiredPortRule() {
		return getRequiredPortAccess().getRule();
	}

	//// an interface has a name, and contains a number
	//// of message interactions (i.e. messages of different 
	//// kinds)
	//Interface:
	//	"interface" name=ID "{" interactions+=MessageInteraction* "}";
	public InterfaceElements getInterfaceAccess() {
		return (pInterface != null) ? pInterface : (pInterface = new InterfaceElements());
	}
	
	public ParserRule getInterfaceRule() {
		return getInterfaceAccess().getRule();
	}

	//// message interactions are either oneways
	//// or request/replies
	//MessageInteraction:
	//	OnewayInteraction | RequestReplyInteraction;
	public MessageInteractionElements getMessageInteractionAccess() {
		return (pMessageInteraction != null) ? pMessageInteraction : (pMessageInteraction = new MessageInteractionElements());
	}
	
	public ParserRule getMessageInteractionRule() {
		return getMessageInteractionAccess().getRule();
	}

	//// oneway interactions have a name and a message
	//OnewayInteraction:
	//	"oneway" name=ID ":" message=Message;
	public OnewayInteractionElements getOnewayInteractionAccess() {
		return (pOnewayInteraction != null) ? pOnewayInteraction : (pOnewayInteraction = new OnewayInteractionElements());
	}
	
	public ParserRule getOnewayInteractionRule() {
		return getOnewayInteractionAccess().getRule();
	}

	//// request/reply has a name and two messages
	//RequestReplyInteraction:
	//	"rr" name=ID ":" "request" "=" request=Message "reply" "=" reply=Message;
	public RequestReplyInteractionElements getRequestReplyInteractionAccess() {
		return (pRequestReplyInteraction != null) ? pRequestReplyInteraction : (pRequestReplyInteraction = new RequestReplyInteractionElements());
	}
	
	public ParserRule getRequestReplyInteractionRule() {
		return getRequestReplyInteractionAccess().getRule();
	}

	//// a message is a list of message parameters
	//Message:
	//	"(" (parameters+=MessageParameter ","?)* ")";
	public MessageElements getMessageAccess() {
		return (pMessage != null) ? pMessage : (pMessage = new MessageElements());
	}
	
	public ParserRule getMessageRule() {
		return getMessageAccess().getRule();
	}

	//// and a message parameter has an ID and a type
	//// top level element is the file which
	//// can import other files and contains 
	//// a top level, root namespace
	/// *
	//File: 
	//	(featureModel=FeatureModelImport)?
	//	(imports+=Import)*
	//	(systems+=System |
	//	 compositions+=Composition |
	//	 topology+=Topology |
	//	 deployments+=Deployment |
	//	 makeFiles+=MakeFile)*;
	//
	//MakeFile:
	//	"make" name=ID "deployment" deployment=[Deployment] "{"
	//		(generatedComponnetAPIs+=ComponentAPIGenerationSpec)*
	//	"}";
	//
	//ComponentAPIGenerationSpec:
	//	"component" component=[Component];
	//
	//Topology:
	//	"topology" name=ID "{"
	//		(node+=Node)*
	//	"}";
	//
	//Node:
	//	AppServerNode | DbServerNode;
	//	
	//AppServerNode:
	//	"appserver" name=ID (clustered?="clustered")?;
	//
	//DbServerNode:
	//	"dbserver" name=ID (clustered?="clustered")?;
	//	
	//
	//Deployment:
	//	"deployment" name=ID 
	//		"deliverablesystem" deliverableSystem=[Composition]
	//		"topology" topology=[Topology] "{"
	//		(mappings+=InstanceNodeMapping)*
	//	"}";
	//	
	//InstanceNodeMapping:
	//	"map" nodeRef=[Node] "{"
	//		(instances+=InstanceRef)*
	//	"}";
	//		
	//InstanceRef:
	//	"instance" instance=[Instance];
	//	
	//
	//// an import makes another file accessible
	//// the current one          
	//Import:
	//	"import" importURI=STRING;
	//         
	//// namespaces are tne primary container of stuff,
	//// they can use other namespaces and can be nested 
	//System:
	//	(pointcut=Pointcut)?
	//	"system" name=ID 
	//	(tags=TagsClause)?
	//	(featureClause=FeatureClause)? 
	//	  "{"
	//		(usings+=Using)*	
	//		( subSystems+=System 
	//		  | components+=Component 
	//		  | datatypes+=DataType
	//		  | interfaces+=Interface
	//		 )* 
	//	"}"; 
	//
	//// using makes the contents of another system
	//// visible in the containing namespace. 
	//// note that the Using construct does not directly use a "reference to namespace"
	//// as the type of it's namespace property, because it is possible to have several
	//// namespace objects with the same (qualified) name! 
	//Using:
	//	"using" system=QualID ";";	
	//	
	//// components have names and ports
	//Component:
	//	UiComponent | BlComponent | PersComponent;
	//	
	//UiComponent:
	//	(pointcut=Pointcut)?
	//	"uicomponent" name=ID
	//	(tags=TagsClause)? 
	//	(featureClause=FeatureClause)?
	//	"{" 
	//		(ports+=Port)*
	//		(configuration=ComponentConfiguration)?		
	//	"}";
	//	
	//BlComponent:
	//	(pointcut=Pointcut)?
	//	"blcomponent" name=ID
	//	(tags=TagsClause)?
	//	(featureClause=FeatureClause)?
	//	"{" 
	//		(ports+=Port)*
	//		(configuration=ComponentConfiguration)?		
	//	"}";
	//	
	//PersComponent:
	//	(pointcut=Pointcut)?
	//	"persistencecomponent" name=ID 
	//	(tags=TagsClause)?
	//	(featureClause=FeatureClause)?
	//	"{" 
	//		(ports+=Port)*
	//		(configuration=ComponentConfiguration)?		
	//	"}";
	//	
	//// a port is either a provided port or a required port
	//Port:
	//	ProvidedPort | RequiredPort;
	//
	//// provided ports offer interfaces for use by other
	//// components. Ports can be mandatory and/or expect 
	//// a collection of clients. Ports also have a name.
	//ProvidedPort:
	//	"provides"
	//	(isMandatory?="mandatory")? 
	//	(isToMany?="toMany")? 
	//	name=ID ":" interface=[Interface|ID] 
	//    (featureClause=FeatureClause)? ";";
	//		
	//// required ports access interfaces provided by other
	//// components. Ports can be mandatory and/or connect to
	//// a collection of providers. Ports also have a name.
	//RequiredPort:
	//	"requires" 
	//	(isMandatory?="mandatory")? 
	//	(isToMany?="toMany")? 
	//	name=ID ":" interface=[Interface|ID] 
	//	(featureClause=FeatureClause)? ";";
	//
	//// an interface has a name, and contains a number
	//// of message interactions (i.e. messages of different 
	//// kinds)
	//Interface:
	//	"interface" name=ID (featureClause=FeatureClause)? 
	//	"{"
	//		(interactions+=MessageInteraction)*
	//	"}"; 
	//	
	//// message interactions are either oneways
	//// or request/replies
	//MessageInteraction:
	//	OnewayInteraction | RequestReplyInteraction;
	//	
	//// oneway interactions have a name and a message
	//OnewayInteraction:
	//	"oneway" name=ID ":" message=Message 
	//	(featureClause=FeatureClause)? ";";
	//
	//// request/reply has a name and two messages
	//RequestReplyInteraction:
	//	"rr" name=ID ":" "request" "=" request=Message "reply" "=" reply=Message 
	//	(featureClause=FeatureClause)? ";";
	// 	
	//// a message is a list of message parameters
	//Message:
	//	"(" (parameters+=MessageParameter (",")?)* ")";
	//	
	//// and a message parameter has an ID and a type
	//MessageParameter:
	//	name=ID ":" typeref=AnyTypeRef (featureClause=FeatureClause)?;	
	//
	//// data types are either primitive or complex	
	//DataType:
	//	PrimitiveType | ComplexType;
	//
	//// primitive types just have a name
	//PrimitiveType: 
	//	"primitive" name=ID 
	//	(featureClause=FeatureClause)? ";";	
	//
	//// complex types have a name and attributes
	//ComplexType: 
	//	"struct" name=ID 
	//	"{"
	//		(attributes+=Attribute)*
	//	"}";	
	//	 
	//// and attribute has a name and a type ref
	//Attribute:
	//	name=ID ":" typeref=AnyTypeRef 
	//	(featureClause=FeatureClause)? ";";	
	//	
	//// we use the typeref construct as the way to
	//// capture type modifers such as collections
	//// there are primitive type refs and any type refs	
	//DataTypeRef:
	//	PrimitiveTypeRef | AnyTypeRef;
	//	
	//// simple type refs are those without collections...	
	//AnyTypeRef:
	//	SimpleTypeRef | CollectionTypeRef;
	//
	//// for reasons of polymorphism, we type the type attribute
	//// to DataType, and not primitive type. Compensated via 
	//// Constraints and CC
	//PrimitiveTypeRef:
	//	type=[DataType|ID];  
	//	
	//// a refernece to a simple type
	//SimpleTypeRef:
	//	type=[DataType|ID];
	//	
	//// a collection of any type
	//CollectionTypeRef:
	//	"collection" type=[DataType|ID] ";";
	//	
	//	
	//
	//// a composition is a names collection of 
	//// instances and connectors
	//Composition:
	//	"deliverablesystem" name=ID (featureClause=FeatureClause)? "{"
	//		(instances+=Instance |
	//		 connectors+=Connector)*
	//	"}";
	//
	//// an instance is an inszance of a component	
	//Instance:
	//	"instance" name=ID ":" type=[Component]
	//		(configuration=InstanceConfiguration)?	
	//	 (featureClause=FeatureClause)? ";";	
	//
	//// a connector connects source ports with target ports
	//Connector:
	//	"connect" source=InstancePortPair "to" target=InstancePortPair ";";
	//
	//// references an instance/port tuple
	//InstancePortPair:
	//	instance=[Instance] "." port=[Port];	
	//
	//
	//ComponentConfiguration:
	//	"config" "{" 
	//		(params+=ConfigurationParameter)*
	//	"}";
	//
	//
	//ConfigurationParameter:
	//	valueTime=ValueTimeEnum name=ID ":" type=ConfigParamTypeEnum;
	//	 
	//InstanceConfiguration:
	//	"config" "{" 
	//		(settings+=ConfigurationParameterSetting)* 
	//	"}";	
	//	
	//enum ConfigParamTypeEnum:
	//	NUMBER = "numeric" | 
	//	TEXT = "text" | 
	//	BOOL = "boolean"; 	
	//	
	//ConfigurationParameterSetting:
	//	param=[ConfigurationParameter|ID] "=" value=ConfigurationParameterValue;
	//	
	//ConfigurationParameterValue:	
	//	NumericConfigurationParameterValue | 
	//	TextConfigurationParameterValue | 
	//	BooleanConfigurationParameterValue;
	//	
	//NumericConfigurationParameterValue:
	//	value=INT;
	// 
	//TextConfigurationParameterValue:
	//	value=STRING;
	// 
	//BooleanConfigurationParameterValue:
	//	value=BooleanLiteral;
	//	
	//BooleanLiteral:
	//	TrueLiteral | FalseLiteral;
	//		
	//TrueLiteral: "true";
	//
	//FalseLiteral: "false";		
	//	
	//enum ValueTimeEnum:
	//    NEVER="never (dummy)"  
	//	| INSTANCEDEFINITION="instancedef"
	//	| DEPLOYMENT="deployment"
	//	| STARTUP="startup"
	//	;
	//
	//	
	//// a tokenizer pattern for dot-separated names
	//QualID: ID ("." ID)*;
	//
	//
	////{ Feature Stuff 
	//// ******************
	//
	//FeatureClause:
	//	FeatureAndList | FeatureOrList | FeatureExpression | Feature ;
	//
	//FeatureAndList:
	//	"featureAndList" (retained?="retain")? "(" featureList+=ID ("," featureList+=ID)* ")";
	//  
	//FeatureOrList:  
	//	"featureOrList" (retained?="retain")? "(" featureList+=ID ("," featureList+=ID)* ")";
	//    
	//FeatureExpression:
	//	"featureExp" (retained?="retain")? "(" expression=OrExpression ")";     
	//    
	//Feature:
	//	"feature" (retained?="retain")? feature=ID;
	//	
	//OrExpression:
	//	operands+=AndExpression ("or" operands+=AndExpression)*;
	//
	//AndExpression:
	//	operands+=Operand ("and" operands+=Operand)*;
	//
	//Operand:
	//	(isNot?="not")? expression=Atom;
	//
	//Atom:
	//	feature=ID | "(" expression=OrExpression ")";	
	//	
	//FeatureModelImport:
	//	"featuremodel" uri=STRING ";";
	////}	
	//
	////{ Aspect Stuff
	//// *****************
	//TagsClause: 
	//	{TagsClause}
	//	"tags" "(" (tags+=Tag)* ")"; 
	//  
	//Tag: 
	//	name=ID;   
	//  
	// 
	//Pointcut:
	//	{Pointcut} 
	//	"aspect" "{" (matches+=Match)* "}"; 
	//  
	//Match: 
	//	AllMatch | ExactNameMatch | StartsWithNameMatch | EndsWithNameMatch | TagMatch ;
	//  
	//  
	//AllMatch: 
	//	"*"; 
	//  
	//ExactNameMatch: 
	//	"name" "=" name=ID; 
	//  
	//StartsWithNameMatch: 
	//	"name" "=" name=ID "*"; 
	//  
	//EndsWithNameMatch: 
	//	"name" "="  "*" name=ID; 
	//  
	//TagMatch: 
	//	"tag" "=" name=ID; 
	// * / MessageParameter:
	//	name=ID ":" typeref=[mm::Entity|QualifiedName];
	public MessageParameterElements getMessageParameterAccess() {
		return (pMessageParameter != null) ? pMessageParameter : (pMessageParameter = new MessageParameterElements());
	}
	
	public ParserRule getMessageParameterRule() {
		return getMessageParameterAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
