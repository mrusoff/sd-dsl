/*
 * generated by Xtext
 */
package fr.chaunier.xtext.omcst.om.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import fr.chaunier.xtext.omcst.om.omcstDsl.*
import fr.chaunier.xtext.omcst.om.OmcstExtensions
import com.google.inject.Inject
import static extension org.eclipse.xtext.xtend2.lib.ResourceExtensions.*


class OmcstDslGenerator implements IGenerator {

  @Inject extension GeneratorExtensions generatorExtensions
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val textileGenerator = new TextileGenerator()
		val xsdGenerator = new XsdGenerator()
	    for(packageDeclaration : resource.allContentsIterable.filter(typeof(PackageDeclaration))) {
//	      fsa.generateFile(packageDeclaration.fileName, packageDeclaration.compileXsd())
	      fsa.generateFile(packageDeclaration.fileName, xsdGenerator.compileXsd(packageDeclaration))
	      fsa.generateFile(packageDeclaration.fileTxtName, textileGenerator.compileTxt(packageDeclaration,generatorExtensions))
    	}
	}

/*
  def compileXsd(PackageDeclaration pac) '''
    «val importManager = new ImportManager()»
    «val body = body(pac, importManager)»
<?xml version="1.0" encoding="UTF-8" ?>
<xsd:schema xmlns:«pac.prefix»="«pac.namespace»" 
attributeFormDefault="unqualified" 
elementFormDefault="unqualified" 
targetNamespace="«pac.namespace»"
xmlns:xsd="http://www.w3.org/2001/XMLSchema"
«val pcks = importManager.getImportPackages(pac)»
«FOR i:pcks»
xmlns:«i.prefix»="«i.namespace»"
«ENDFOR»
>
    «FOR i:pcks»
	<xsd:import schemaLocation="«i.prefix»" namespace="«i.namespace»"></xsd:import>
    «ENDFOR»
    «body»
  '''
  
  
  def body(PackageDeclaration p, ImportManager importManager) '''
      «FOR t:p.elements.filter(typeof(DataType))»	
        «type(t, importManager)»
      «ENDFOR»
      «FOR t:p.elements.filter(typeof(Entity))»	
        «type(t, importManager)»
      «ENDFOR»
      «FOR t:p.elements.filter(typeof(Enumeration))»	
        «type(t, importManager)»
      «ENDFOR»
    </xsd:schema>  
  '''

  def dispatch type(Entity e, ImportManager importManager) '''
  <xsd:complexType name="«e.name()»Type">
	«IF e.superType != null»   
  	<xsd:complexContent>
  	«val pac = new OmcstExtensions()»
  	<xsd:extension base="«pac.getPackage(e.superType)»:«e.superType.name()»Type"»>
 	«ENDIF» 	
    <xsd:annotation>
      <xsd:documentation>«e.description»</xsd:documentation>
    </xsd:annotation>
       <xsd:sequence>
    «FOR f:e.features.filter(typeof(Attribute))»
       «feature(f, importManager)»
    «ENDFOR»
       </xsd:sequence>
«IF e.superType!=null»   
  	</xsd:extension>
  	</xsd:complexContent>
 «ENDIF» 	
	</xsd:complexType>  
  '''

  def dispatch feature(Attribute a, ImportManager importManager) '''
   «a.type.referenced.shortName(importManager)» 
   <xsd:element name="«a.name»" type=xsd:string>
	<xsd:annotation>
    	<xsd:documentation>«a.description»</xsd:documentation>
       </xsd:annotation>
    </xsd:element>	
  '''

  def dispatch type(DataType d, ImportManager importManager) '''
    datatype «d.name» 
  '''
  
  def dispatch type(Enumeration e, ImportManager importManager) '''
  	<xsd:simpleType name="«e.name»Enum">
    	<xsd:restriction base="xsd:string">
      «FOR l:e.enumerationLiterals»
			<xsd:enumeration value="«l.name»"/>
      «ENDFOR»	
	  <xsd:enumeration value="INCONNU_«e.name»«e.enumerationLiterals.size+1»"/> 
	  <xsd:enumeration value="INCONNU_«e.name»«e.enumerationLiterals.size+2»"/> 
  '''
 */
	
}
	
	
