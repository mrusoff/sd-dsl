
/*
 * generated by Xtext
 */
package fr.chaunier.xtext.mapping.generator

import fr.chaunier.xtext.omcst.om.omcstDsl.*
import fr.chaunier.xtext.omcst.om.OmcstExtensions
import org.eclipse.xtext.naming.DefaultDeclarativeQualifiedNameProvider
import fr.chaunier.xtext.mapping.mapDsl.*
import fr.chaunier.xtext.omcst.om.OmHelper
//import fr.chaunier.xtext.omcst.om.path.PathByEntity
import org.eclipse.xtext.util.Pair
import static org.eclipse.xtext.util.Tuples
import java.util.List
import java.util.ArrayList
import fr.chaunier.xtext.omcst.om.InstancePathManager
import fr.chaunier.xtext.omcst.om.FeaturePathBuilder
import fr.chaunier.xtext.omcst.om.OmHelper 

class DeprecatedTextileGenerator  {

  def concatPath(String prefix, String suffix) {
    if (prefix.nullOrEmpty)
      suffix
    else if (suffix.nullOrEmpty)
      prefix	
    else prefix + "." + suffix
  }


def compileTxt(ModelMap mdl) '''
«var omHelper = new OmHelper()»
h1. model «mdl.name» 

h2. from «omHelper.QualifiedName(mdl.entityFrom)» to «omHelper.QualifiedName(mdl.entityTo)»

h2. mapping view

table{border:1px solid black}.
| **source** |  | **destination** | | | 
«var mapPaths = new ArrayList<Pair<String,String>>()»
«FOR f:mdl.actions»
	«mapActionTxt(f,mapPaths)»
«ENDFOR»
«FOR mapFromTo:mapPaths»
| «mapFromTo.first» | -> | «mapFromTo.second»  
«ENDFOR»

h2. source oriented view

«var path = new FeaturePathBuilder()»
«var instanceManagerFrom = new InstancePathManager(mdl.entityFrom)»
«var instanceManagerTo = new InstancePathManager(mdl.entityTo)»
«path.compilePath(mdl.entityTo,instanceManagerTo)»
«path.compilePath(mdl.entityFrom,instanceManagerFrom)»

table{border:1px solid black}.
| **source** |  | **destination** | source type | dest type | 
«FOR pFrom:instanceManagerFrom.paths»
«val pTo = searchCorrespondingPathIn(pFrom,mapPaths)» 
| «pFrom» |  -> |  «pTo» | «getFeatureString(pFrom,instanceManagerFrom)» | «getFeatureString(pTo,instanceManagerTo)»  
«ENDFOR»

h2. destination oriented view

table{border:1px solid black}.
| **source** |  | **destination** | source type | dest type |
«FOR pTo:instanceManagerTo.paths»
«val pFrom = searchCorrespondingPathOut(pTo,mapPaths)» 
| «pFrom» |  -> | «pTo» | «getFeatureString(pFrom,instanceManagerFrom)» | «getFeatureString(pTo,instanceManagerTo)»   
«ENDFOR»

'''


def getFeatureString(String path,InstancePathManager instancePathManager) {
	var feature = instancePathManager.getFeature(path)
	var omHelper = new OmHelper()
	switch(feature) {
		Attribute : omHelper.QualifiedName(feature.type.referenced)
		Reference : omHelper.QualifiedName(feature.type.referenced)
	}
}

def searchCorrespondingPathIn(String path,ArrayList<Pair<String,String>> mapPair) {
	for (map:mapPair) {
		if ( path.equals(map.first))
			return map.second  
	} 
	return null 
} 

def searchCorrespondingPathOut(String path,ArrayList<Pair<String,String>> mapPair) {
	for (map:mapPair) {
		if ( path.equals(map.second))
			return map.first  
	} 
	return null 
} 

	def dispatch mapActionTxt(FunctionDef fd,List<Pair<String,String>> maps) {}
	//	«fd.params»
	
	def dispatch mapActionTxt(RuleDef fd,List<Pair<String,String>> maps) {}
	
	def dispatch mapActionTxt(MapGroup mg,List<Pair<String,String>> maps) {
	for (fp:mg.featurePath)
		mapFeatureString(fp,maps)
	return null	
	}

 
	def dispatch mapFeatureString(FeatureAll fp,List<Pair<String,String>> maps) {}
	
	def dispatch mapFeatureString(FeatureSet fp,List<Pair<String,String>> maps) {}
	
	def dispatch mapFeatureString(FeaturePath fp,List<Pair<String,String>> maps) {
		val t = Tuples::pair(pathString(fp.from.path),pathString(fp.to.path))
		maps.add(t)
	}

	// build the path string
	def pathString(Path path) {
		var omHelper = new OmHelper()
		var map = mapFeatureString(path,'')
//		omHelper.QualifiedName(entity).toString+':'+map
		'' + map
	}

	// dump the path for feature
	def dispatch mapFeatureString(Path p,String pathStr) {
	    return concatPath(p.attribute.name,pathStr)
    }

    def dispatch mapFeatureString(PathParam p,String pathStr) {
	   if (p.refAttribute != null) {
		   var path = concatPath(p.refAttribute.name,pathStr)
		   if ( p.target != null)
			   return mapFeatureString(p.target,path)
		   else return path	
	}
}

	// dump the paths for entity
	def pathList(InstancePathManager instancePathManager) {
    	val builder = new StringBuilder()
    	for (p : instancePathManager.paths) {
    		builder.append(p);
    		builder.append('\n');
    	} 
    	builder.toString
  	}


}
	
