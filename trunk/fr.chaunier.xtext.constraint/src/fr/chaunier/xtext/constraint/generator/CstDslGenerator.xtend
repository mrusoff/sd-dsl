/*
 * generated by Xtext
 */
package fr.chaunier.xtext.constraint.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import fr.chaunier.xtext.om.omDsl.*
import fr.chaunier.xtext.constraint.cstDsl.*
import com.google.inject.Inject
import static extension org.eclipse.xtext.xtend2.lib.ResourceExtensions.*

class CstDslGenerator implements IGenerator {
	
  @Inject extension GeneratorExtensions generatorExtensions
	
  override void doGenerate(Resource resource, IFileSystemAccess fsa) {
    val constraintManager = new fr.chaunier.xtext.constraint.generator.PackageManager()
    val Iterable<PackageConstraint> packageCtss = resource.allContentsIterable.filter(typeof(PackageConstraint));
    for(packageCts: packageCtss ) {
    	constraintManager.appendPackage(packageCts);
    	packageCts.prefix
    }
    for(packageCts: packageCtss ) {
	    genFile(constraintManager,packageCtss,fsa)
    }
  }

  def genFile(fr.chaunier.xtext.constraint.generator.PackageManager constraintManager,Iterable<PackageConstraint> packageCts,IFileSystemAccess fsa) {
      for( PackageCts: packageCts ) {
        fsa.generateFile(PackageCts.fileName, compile(constraintManager,PackageCts))
//      	  fsa.generateFile(PackageCts.fileName, PackageCts.compile)
      }
  }

  def body(PackageConstraint p, fr.chaunier.xtext.constraint.generator.PackageManager importManager) '''
      «FOR t:p.types.filter(typeof(DataTypeConstraint))»	
        «type(t.dataType, importManager)»
      «ENDFOR»
      «FOR t:p.types.filter(typeof(EntityConstraint))»	
        «type(t.entity, importManager)»
      «ENDFOR»
    </xsd:schema>  
  '''

  def dispatch type(EntityConstraint e, fr.chaunier.xtext.constraint.generator.PackageManager importManager) '''
  <xsd:complexType name="«e.entity.name()»Type">
	«IF e.entity.superType != null»   
  	<xsd:complexContent>
  	<xsd:extension base=>
 	«ENDIF» 	
    <xsd:annotation>
      <xsd:documentation>«e.description»</xsd:documentation>
    </xsd:annotation>
       <xsd:sequence>
    «FOR f:e.features.filter(typeof(AttributeConstraint))»
       «feature(f, importManager)»
    «ENDFOR»
       </xsd:sequence>
«IF e.entity.superType!=null»   
  	</xsd:extension>
  	</xsd:complexContent>
 «ENDIF» 	
	</xsd:complexType>  
  '''

  def dispatch type(Entity e, fr.chaunier.xtext.constraint.generator.PackageManager importManager) '''
  <xsd:complexType name="«e.name()»Type">
	«IF e.superType != null»   
  	<xsd:complexContent>
  	<xsd:extension base=>
 	«ENDIF» 	
    <xsd:annotation>
      <xsd:documentation>«e.description»</xsd:documentation>
    </xsd:annotation>
       <xsd:sequence>
    «FOR f:e.features.filter(typeof(Attribute))»
       «feature(f, importManager)»
    «ENDFOR»
       </xsd:sequence>
«IF e.superType!=null»   
  	</xsd:extension>
  	</xsd:complexContent>
 «ENDIF» 	
	</xsd:complexType>  
  '''

  def dispatch type(DataType d, fr.chaunier.xtext.constraint.generator.PackageManager importManager) '''
    datatype «d.name» {
  '''

  def body(DataTypeConstraint e, fr.chaunier.xtext.constraint.generator.PackageManager importManager) '''
    datatype «e.dataType.name» {
    }
  '''

  def dispatch feature(Attribute a, fr.chaunier.xtext.constraint.generator.PackageManager importManager) '''
   «a.type.referenced.shortName(importManager)» 
   <xsd:element name="«a.name»" type=xsd:string>
	<xsd:annotation>
    	<xsd:documentation>«a.description»</xsd:documentation>
       </xsd:annotation>
    </xsd:element>	
  '''

  def dispatch feature(AttributeConstraint a, fr.chaunier.xtext.constraint.generator.PackageManager importManager) '''
   «a.attribute.type.referenced.shortName(importManager)» 
   <xsd:element name="«a.attribute.name»" type=xsd:string>
	<xsd:annotation>
    	<xsd:documentation>«a.attribute.description»</xsd:documentation>
       </xsd:annotation>
    </xsd:element>	
  '''

  def compile(fr.chaunier.xtext.constraint.generator.PackageManager constraintManager ,PackageConstraint e) '''
    «val body = body(e, constraintManager)»
<?xml version="1.0" encoding="UTF-8" ?>
<xsd:schema xmlns:«e.prefix»="«e.namespace»" 
attributeFormDefault="unqualified" 
elementFormDefault="unqualified" 
targetNamespace="«e.namespace»"
xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    «FOR i:constraintManager.getImports»
      import «i»;
    «ENDFOR»
    «val pks = constraintManager.importPackageConstraints»
    remove : «pks.remove(e)»
    «FOR i:pks»
      import «i.packageDeclaration.name» «i.prefix» «i.namespace» ;
    «ENDFOR»
>
    «body»
  '''
	
}
